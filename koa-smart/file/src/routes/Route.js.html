<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/routes/Route.js | koa-smart</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="A framework base on Koajs2 with Decorator, Params checker and a base of modules (cors, bodyparser, compress, I18n, etc&#x2026;) to let you develop smart api easily"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="koa-smart"><meta property="twitter:description" content="A framework base on Koajs2 with Decorator, Params checker and a base of modules (cors, bodyparser, compress, I18n, etc&#x2026;) to let you develop smart api easily"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ysocorp/koa-smart"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/App.js~App.html">App</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#middlewares">middlewares</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-handleError">handleError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-OptionErrors">OptionErrors</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#routes">routes</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/routes/Route.js~Route.html">Route</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-BeforeRouteParams">BeforeRouteParams</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Decorator">Decorator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ParamMiddlewareFunction">ParamMiddlewareFunction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-PostParamsFilter">PostParamsFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouteParams">RouteParams</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ParamsClassDecorator">ParamsClassDecorator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ParamsMethodDecorator">ParamsMethodDecorator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://koajs.com/#application">Koa</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://koajs.com/#api">KoaContext</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#utils">utils</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/ErrorApp.js~ErrorApp.html">ErrorApp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StatusCode">StatusCode</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/routes/Route.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import KoaRouter from &apos;koa-router&apos;;
import chalk from &apos;chalk&apos;;
import { RateLimit } from &apos;koa2-ratelimit&apos;;

import ErrorApp from &apos;../utils/ErrorApp&apos;;
import StatusCode from &apos;../utils/StatusCode&apos;;
import { isArray, isObject, deepCopy } from &apos;../utils/utils&apos;;
import RouteDecorators from &apos;./RouteDecorators&apos;;


export default class Route {
  /**
   * @type {boolean}
   * @desc if true it will log which route are mount and which are not
   */
  static displayLog = true;  
  /**
  * @type {StatusCode}
  */
  static StatusCode = StatusCode;

  /**
   * @typedef {Object} BeforeRouteParams
   * @property {string} path the path at which the route will be available.
   * @property {ParamsMethodDecorator} options 
   * @property {function} call the fonction to call when route match, this is automaticaly add by route decorator
   */

  /**
   * @typedef {Object} PostParamsFilter
   * @property {ParamMiddlewareFunction[]} __func an array of functions which provides &quot;middleware&quot; functions that will be applied to the corresponding parameter one by one, in order to validate or transform it
   * @property {boolean} __force whether the parameter is required or not.
   */

  /**
   * @typedef {function} ParamMiddlewareFunction
   * @param {*} elem the element the function will act upon
   * @param {Route} [route] the element&apos;s current route
   * @param {{ctx: KoaContext, body:Object, keyBody:string}} [context] the element&apos;s context
   * @return {*} transformedParam the parameter, after being manipulated by the function
   */

  /**
   * @typedef {Object} RouteParams
   * @property {Koa} app the Koa application
   * @property {string} prefix a prefix which will be preppended before every route&apos;s paths
   * @property {Route[]} routes an array containing all the mounted Routes
   * @property {Model[]} [models] an array containing all of the app&apos;s models
   * @property {string} [model] the name of the route&apos;s own model
   * @property {disable} [boolean] whether the route should be disabled
   *
   */

   /**
    * @typedef {function} Decorator
    * @return { }
    */

  /**
   * @external {KoaContext} http://koajs.com/#api
   */

   /**
    * @external {Koa} http://koajs.com/#application
    */

   /**
    * @param {RouteParams} params the route&apos;s parameters
    */
  constructor({ app, prefix, routes, models, model, disable }) {
    /**
     * @type {Koa}
     * @desc the main Koa application
     */
    this.app = app;
    /**
     * @type {string}
     * @desc the route&apos;s prefix
     */
    this.prefix = prefix;
    /**
     * @type {Route[]}
     * @desc an array composed of all the availble routes in the application
     */
    this.allRoutesInstance = routes;
    /**
     * @type {Model[]}
     * @desc an array of all the models available in the application
     */
    this.models = models;
    /**
     * @type {boolean}
     * @desc whether the route should be disabled. disabled routes cannot be called.
     */
    this.disable = disable != null ? disable : this.disable;
    /**
     * @type {function[]}
     * @desc the route&apos;s registered middlewares
     */
    this.middlewares = this.middlewares || [];
    if (this.models &amp;&amp; model) {
      /**
       * @type {Model|undefined}
       * @desc the route&apos;s own model
       */
      this.model = this.models[model];
    }
    /**
     * @type {KoaRouter}
     * @desc the underlying koa router for this particular route
     */

    this.koaRouter = new KoaRouter();
    /**
     * @ignore
     */
    this.privateKeyInParamsRoute = [&apos;__force&apos;, &apos;__func&apos;];
    // This Variable are set by RouteDecorators
    this.routes;
    this.routeBase;
  }


 /**
  * @access public
  * @desc mounts the tagged function as a GET route.
  * @param {ParamsMethodDecorator} params the route&apos;s parameters
  * @return {Decorator}
  */
  static Get = RouteDecorators.Get;

 /**
  * @access public
  * @desc mounts the tagged function as a POST route.
  * @param {ParamsMethodDecorator} params the route&apos;s parameters
  * @return {Decorator}
  */
  static Post = RouteDecorators.Post;

 /**
  * @access public
  * @desc mounts the tagged function as a PUT route.
  * @param {ParamsMethodDecorator} params the route&apos;s parameters
  * @return {Decorator}
  */
  static Put = RouteDecorators.Put;

 /**
  * @access public
  * @desc mounts the tagged function as a PATCH route.
  * @param {ParamsMethodDecorator} params the route&apos;s parameters
  * @return {Decorator}
  */
  static Patch = RouteDecorators.Patch;

 /**
  * @access public
  * @desc mounts the tagged function as a DELETE route.
  * @param {ParamsMethodDecorator} params the route&apos;s parameters
  * @return {Decorator}
  */
  static Delete = RouteDecorators.Delete;

 /**
  * @access public
  * @desc used to set some parameters on an entire class.The supported parameters are middlewares, disable, and routeBase.
  * @return {Decorator}
  * @param {ParamsClassDecorator} params the route&apos;s parameters
  */
  static Route = RouteDecorators.Route;

  /**
   * logs a message, but only if the route&apos;s logs are set to be displayed.
   *
   * accepts several parameters
   */
  log(str, ...args) {
    if (Route.displayLog) {
      console.log(str, ...args);
    }
  }

  /**
   * @access public
   * @desc Registers the route and makes it callable once the API is launched.
   *       the route will be called along with the middlewares that were registered in the decorator.
   *
   *       you will usually not need to call this method yourself.
   */
  mount() {
    if (this.disable !== true) {
      for (const type in this.routes) { // eslint-disable-line
        for (const route of this.routes[type]) {
          const routePath = `/${this.prefix}/${this.routeBase}/${route.path}`.replace(/[/]{2,10}/g, &apos;/&apos;);
          route.options.routePath = routePath;
          route.options.type = type;
          if (!route.options.disable) {
            this.log(chalk.green.bold(&apos;[Mount route]&apos;), `\t${type}\t`, routePath);
            this.koaRouter[type](routePath, ...this._use(route));
          } else {
            this.log(chalk.yellow.bold(&apos;[Disable Mount route]\t&apos;), type, routePath);
          }
        }
      }
    } else {
      this.log(chalk.yellow.bold(`Routes &quot;${this.routeBase}&quot; of class ${this.constructor.name} are&apos;t add`));
    }
  }

  // ************************************ MIDDLEWARE *********************************
  /**
   *@ignore
   */
   _use(infos) {
    const { options = {} } = infos;
    const { middlewares = [] } = options;

    const middlewaresToAdd = [this._beforeRoute(infos)];
    middlewaresToAdd.push(...this.middlewares); // add middlewares of the class
    middlewaresToAdd.push(...middlewares); // add middlewares of the specific route
    this.addRateLimit(middlewaresToAdd, infos);
    middlewaresToAdd.push(infos.call.bind(this));

    return middlewaresToAdd;
  }

  /**
   *@ignore
   */
  getRateLimit(option, routePath, type) {
    option.interval = RateLimit.RateLimit.timeToMs(option.interval);
    return RateLimit.middleware({
      prefixKey: `${type}|${routePath}|${option.interval}`,
      ...option,
    });
  }

  /**
   * if a decorator has a rateLimit property, it will add the rate limiting mechanism to the route,
   * with a unique ID for each route in order to differentiate the various routes.
   *
   * You should not need to call this method directly.
   * @param {function[]} middlewares the array of currently registered middlewares for the given route
   * @param {{options:{rateLimit:Object,routePath:string,type:string}}} params the route&apos;s parameters
   */
  addRateLimit(middlewares, { options }) {
    const { rateLimit, routePath, type } = options;

    if (rateLimit) {
      if (Array.isArray(rateLimit)) {
        for (const elem of rateLimit) {
          middlewares.push(this.getRateLimit(elem, routePath, type));
        }
      } else {
        middlewares.push(this.getRateLimit(rateLimit, routePath, type));
      }
    }
  }

  // beforeRoute
  /**
   *@ignore
   */
  _beforeRoute(infos) {
    return async (ctx, next) =&gt; await this.beforeRoute(ctx, infos, next);
  }

  /**
   * @desc a member which can be overriden, which will always be executed before the route is accessed
   * @param {KoaContext} ctx Koa&apos;s context object
   * @param {BeforeRouteParams} params an object containing all route parameters
   * @param {function} next the next middleware in the chain
   */
  async beforeRoute(ctx, { options }, next) {
    this._mlParams(ctx, options);
    if (next) {
      await next();
    }
  }

  // test params
  /**
   *@ignore
   */
  _mlParams(ctx, { params }) {
    ctx.request.bodyOrig = deepCopy(ctx.request.body);
    ctx.request.body = this._mlTestParams(ctx, ctx.request.body, params);
  }

  /**
   *@ignore
   */
  _mlParamsExecFunc(ctx, body, keyBody, param) {
    if (body &amp;&amp; body[keyBody]) {
      const { __func } = param;
      if (__func &amp;&amp; Array.isArray(__func)) {
        for (const func of __func) {
          body[keyBody] = func(body[keyBody], this, { ctx, body, keyBody });
        }
      }
    }
  }

  /**
   *@ignore
   */
  _mlTestParams(ctx, body, paramsTest) {
    const bodyVerif = {};
    const paramsConvert = this._paramsNormalize(paramsTest);
    for (const key in paramsConvert) {
      const param = paramsConvert[key];

      const bodyElem = body ? body[key] : undefined;
      // test param
      if (param.__force &amp;&amp; (bodyElem === undefined || bodyElem === null)) {
        this.throw(400, `${ctx.state.__ ? ctx.state.__(&apos;param required:&apos;) : &apos;param required:&apos;} ${key}`);
      }
      this._mlParamsExecFunc(ctx, body, key, param);


      if (this._paramsHasSubElement(param)) {
        if (body &amp;&amp; isObject(body)) {
          const tmp = this._mlTestParams(ctx, body[key], param);
          if (body[key]) {
            bodyVerif[key] = tmp;
          }
        } else {
          const tmp = this._mlTestParams(ctx, undefined, param);
          if (body &amp;&amp; isObject(body) &amp;&amp; body[key] !== undefined) {
            bodyVerif[key] = tmp;
          }
        }
      } else if (body &amp;&amp; isObject(body) &amp;&amp; body[key] !== undefined) {
        bodyVerif[key] = body[key];
      }
    }
    return bodyVerif;
  }

  /**
   *@ignore
   */
  _paramsNormalize(paramsTest) {
    let paramsConvert = {};
    // convert array to object
    if (isArray(paramsTest)) {
      for (const elem of paramsTest) {
        if (isObject(elem, false)) {
          paramsConvert = Object.assign(paramsConvert, elem);
        } else {
          paramsConvert[elem] = false;
        }
      }
    } else {
      paramsConvert = paramsTest;
    }

    // normalize objects
    for (const key in paramsConvert) {
      const elem = paramsConvert[key];
      if (!this.privateKeyInParamsRoute.includes(key)) {
        if (isObject(elem) || isArray(elem)) {
          paramsConvert[key] = this._paramsNormalize(elem);
        } else if (elem === false || elem === true) {
          paramsConvert[key] = { __force: elem };
        }
      }
    }
    return paramsConvert;
  }

  /**
   *@ignore
   */
  _paramsHasSubElement(paramsTest) {
    for (const key in paramsTest) {
      if (!this.privateKeyInParamsRoute.includes(key)) {
        return true;
      }
    }
    return false;
  }

  // ************************************ !MIDDLEWARE *********************************

  /**
   *@desc retrieves the context&apos;s body, if the request has one.
   *@param {KoaContext} ctx koa&apos;s context object
   *@param {boolean} [original=false] if set to true, the function will return the body before it is filtered by the param decorator.
   *                                  otherwise, it will return the filtered and transformed body.
   */
  body(ctx, original = false) {
    return original ? ctx.request.bodyOrig : ctx.request.body;
  }

  /**
   * @access public
   * @desc retrieves the query params in a GET request
   * @param {KoaContext} ctx koa&apos;s context object
   * @return {Object.&lt;string, *&gt;}
   */
  bodyGet(ctx) {
    return ctx.request.query || {};
  }

  /**
   * @access public
   * @desc alias of {@link bodyGet}
   * @param {KoaContext} ctx koa&apos;s context object
   * @return {Object.&lt;string, *&gt;}
   */
  paramsGet(ctx) { return this.bodyGet(ctx); }

  /**
   * @access public
   * @desc sets the response&apos;s body (with a message + data field) and status.
   * @param {KoaContext} ctx koa&apos;s context object
   * @param {number} [status] the HTTP status code to end the request with
   * @param {*} [data] the data to be yielded by the requests
   * @param {string} [message] the message to be yielded by the request
   * @return { }
   */
  send(ctx, status = 200, data, message) {
    ctx.body = ctx.body || {}; // add default body
    ctx.status = status;
    // Do not remove this test because if status = 204 || 304, node will remove body
    // see _hasBody on
    // https://github.com/nodejs/node/blob/master/lib/_http_server.js#L235-L250
    if (ctx.body) {
      if (data != null) {
        ctx.body.data = data;
      }
      if (message != null) {
        ctx.body.message = message;
      }
      ctx.body.date = Date.now();
    }
  }

  /**
   * @access public
   * @desc same as {@link send}, but automatically sets the status to 200 OK
   * @param {KoaContext} ctx koa&apos;s context object
   * @param {*} [data] the data to be yielded by the requests
   * @param {string} [message] the message to be yielded by the request
   * @return { }
   */
  sendOk(ctx, data, message) {
    return this.send(ctx, Route.StatusCode.ok, data, message);
  }

  /**
   * @access public
   * @desc same as {@link send}, but automatically sets the status to 201 CREATED
   * @param {KoaContext} ctx koa&apos;s context object
   * @param {*} [data] the data to be yielded by the requests
   * @param {string} [message] the message to be yielded by the request
   * @return { }
   */
  sendCreated(ctx, data, message) {
    return this.send(ctx, Route.StatusCode.created, data, message);
  }

  /**
   * @access public
   * @desc replies with an empty body, yielding 204 NO CONTENT as the status
   * @param {KoaContext} ctx koa&apos;s context object
   * @return { }
   */
  sendNoContent(ctx) {
    return this.send(ctx, Route.StatusCode.noContent);
  }

  /**
   * @access public
   * @desc same as {@link send}, but automatically sets the status to 400 BAD REQUEST
   * @param {KoaContext} ctx koa&apos;s context object
   * @param {*} [data] the data to be yielded by the requests
   * @param {string} [message] the message to be yielded by the request
   * @return { }
   */
  sendBadRequest(ctx, data, message) {
    return this.send(ctx, Route.StatusCode.badRequest, data, message);
  }

  /**
   * @access public
   * @desc same as {@link send}, but automatically sets the status to 401 UNAUTHORIZED
   * @param {KoaContext} ctx koa&apos;s context object
   * @param {*} [data] the data to be yielded by the requests
   * @param {string} [message] the message to be yielded by the request
   * @return { }
   */
  sendUnauthorized(ctx, data, message) {
    return this.send(ctx, Route.StatusCode.unauthorized, data, message);
  }

  /**
   * @access public
   * @desc same as {@link send}, but automatically sets the status to 403 FORBIDDEN
   * @param {KoaContext} ctx koa&apos;s context object
   * @param {*} [data] the data to be yielded by the requests
   * @param {string} [message] the message to be yielded by the request
   * @return { }
   */
  sendForbidden(ctx, data, message) {
    return this.send(ctx, Route.StatusCode.forbidden, data, message);
  }

  /**
   * @access public
   * @desc same as {@link send}, but automatically sets the status to 404 NOT FOUND
   * @param {KoaContext} ctx koa&apos;s context object
   * @param {*} [data] the data to be yielded by the requests
   * @param {string} [message] the message to be yielded by the request
   * @return { }
   */
  sendNotFound(ctx, data, message) {
    return this.send(ctx, Route.StatusCode.notFound, data, message);
  }

  /**
   * @access public
   * @desc same as {@link send}, but automatically sets the status to 500 INTERNAL SERVER ERROR
   * @param {KoaContext} ctx koa&apos;s context object
   * @param {*} [data] the data to be yielded by the requests
   * @param {string} [message] the message to be yielded by the request
   * @return { }
   */
  sendInternalServerError(ctx, data, message) {
    return this.send(ctx, Route.StatusCode.internalServerError, data, message);
  }

  /**
   * @access public
   * @desc throws a formated error to be caught.
   * @param {number} status the error&apos;s HTTP status StatusCode
   * @param {string} message  a message describing the error
   * @param {boolean} translate indicates whether the message should be translated or not
   * @throws {ErrorApp} thrown error.
   * @return { }
   */
  throw(status, message, translate = false) {
    throw new ErrorApp(status, message, translate);
  }

  /**
   * @access public
   * @desc checks a condition. If it evaluates to false, throws a formated error to be caught.
   * @param {boolean} condition if set to false; assert will fail and throw.
   * @param {number} status the error&apos;s HTTP status StatusCode
   * @param {string} message  a message describing the error
   * @param {boolean} translate indicates whether the message should be translated or not
   * @throws {ErrorApp} thrown error, should the assert fail.
   * @return { }
   */
  assert(condition, status, message, translate = false) {
    if (!condition) {
      this.throw(status, message, translate);
    }
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
